#!/bin/bash
#
# This is a rather minimal example Argbash potential
# Example taken from http://argbash.readthedocs.io/en/stable/example.html
#
# ARGBASH_SET_INDENT([  ])
# ARG_RESTRICT_VALUES([no-any-options])
# ARG_OPTIONAL_ACTION([update],[u],[],[])
# ARG_OPTIONAL_ACTION([fresh],[f],[],[])
# ARG_OPTIONAL_ACTION([list],[l],[],[])
# ARG_OPTIONAL_ACTION([describe],[d],[],[])
# ARG_OPTIONAL_ACTION([tree],[t],[],[])
# ARG_OPTIONAL_SINGLE([out],[o],[],[])
# ARG_OPTIONAL_SINGLE([rollback],[r],[],[])
# ARG_OPTIONAL_SINGLE([checkout],[c],[],[])
# ARG_OPTIONAL_SINGLE([build-conf],[b],[],["$HOME"])
# ARG_OPTIONAL_ACTION([help],[h],[],[])
# ARG_POSITIONAL_DOUBLEDASH([])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

# # When called, the process ends.
# Args:
#   $1: The exit message (print to stderr)
#   $2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
#   test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die() {
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo "$1" >&2
  exit "${_ret}"
}

# Function that evaluates whether a value passed to an argument
# does not violate the global rule imposed by the ARG_RESTRICT_VALUES macro:
# The value must not match anything that looks like any long or short option.
# Args:
#   $1: The name of the option
#   $2: The passed value
evaluate_strictness() {
  [[ "$2" =~ ^--?[a-zA-Z] ]] && die "You have passed '$2' as a value of argument '$1'. It looks like that you are trying to pass an option instead of the actual value, which is considered a fatal error."
}

# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option() {
  local first_option all_short_options='fuDHtoldrcvqh'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}
validate_combination() {
  echo "dog"
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_out=
_arg_rollback=
_arg_checkout=
_arg_build_conf="$HOME"

# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help() {
  printf 'Usage: %s [-u|--update] [-f|--fresh] [-l|--list] [-d|--describe] [-t|--tree] [-o|--out <arg>] [-r|--rollback <arg>] [-c|--checkout <arg>] [-b|--build-conf <arg>] [-h|--help]\n' "$0"
}

# The parsing of the command-line
parse_commandline() {
  while test $# -gt 0; do
    _key="$1"
    case "$_key" in
    # The update argurment doesn't accept a value,
    # we expect the --update or -u, so we watch for them.
    -u | --update)
      exit 0
      ;;
    # We support getopts-style short arguments clustering,
    # so as -u doesn't accept value, other short options may be appended to it, so we watch for -u*.
    # After stripping the leading -u from the argument, we have to make sure
    # that the first character that follows coresponds to a short option.
    -u*)
      exit 0
      ;;
    # See the comment of option '--update' to see what's going on here - principle is the same.
    -f | --fresh)
      exit 0
      ;;
    # See the comment of option '-u' to see what's going on here - principle is the same.
    -f*)
      exit 0
      ;;
    # See the comment of option '--update' to see what's going on here - principle is the same.
    -l | --list)
      exit 0
      ;;
    # See the comment of option '-u' to see what's going on here - principle is the same.
    -l*)
      exit 0
      ;;
    # See the comment of option '--update' to see what's going on here - principle is the same.
    -d | --describe)
      exit 0
      ;;
    # See the comment of option '-u' to see what's going on here - principle is the same.
    -d*)
      exit 0
      ;;
    # See the comment of option '--update' to see what's going on here - principle is the same.
    -t | --tree)
      exit 0
      ;;
    # See the comment of option '-u' to see what's going on here - principle is the same.
    -t*)
      exit 0
      ;;
    # We support whitespace as a delimiter between option argument and its value.
    # Therefore, we expect the --out or -o value.
    # so we watch for --out and -o.
    # Since we know that we got the long or short option,
    # we just reach out for the next argument to get the value.
    -o | --out)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_out="$2"
      shift
      evaluate_strictness "$_key" "$_arg_out"
      ;;
    # We support the = as a delimiter between option argument and its value.
    # Therefore, we expect --out=value, so we watch for --out=*
    # For whatever we get, we strip '--out=' using the ${var##--out=} notation
    # to get the argument value
    --out=*)
      _arg_out="${_key##--out=}"
      evaluate_strictness "$_key" "$_arg_out"
      ;;
    # We support getopts-style short arguments grouping,
    # so as -o accepts value, we allow it to be appended to it, so we watch for -o*
    # and we strip the leading -o from the argument string using the ${var##-o} notation.
    -o*)
      _arg_out="${_key##-o}"
      evaluate_strictness "$_key" "$_arg_out"
      ;;
    # See the comment of option '--out' to see what's going on here - principle is the same.
    -r | --rollback)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_rollback="$2"
      shift
      evaluate_strictness "$_key" "$_arg_rollback"
      ;;
    # See the comment of option '--out=' to see what's going on here - principle is the same.
    --rollback=*)
      _arg_rollback="${_key##--rollback=}"
      evaluate_strictness "$_key" "$_arg_rollback"
      ;;
    # See the comment of option '-o' to see what's going on here - principle is the same.
    -r*)
      _arg_rollback="${_key##-r}"
      evaluate_strictness "$_key" "$_arg_rollback"
      ;;
    # See the comment of option '--out' to see what's going on here - principle is the same.
    -c | --checkout)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_checkout="$2"
      shift
      evaluate_strictness "$_key" "$_arg_checkout"
      ;;
    # See the comment of option '--out=' to see what's going on here - principle is the same.
    --checkout=*)
      _arg_checkout="${_key##--checkout=}"
      evaluate_strictness "$_key" "$_arg_checkout"
      ;;
    # See the comment of option '-o' to see what's going on here - principle is the same.
    -c*)
      _arg_checkout="${_key##-c}"
      evaluate_strictness "$_key" "$_arg_checkout"
      ;;
    # See the comment of option '--out' to see what's going on here - principle is the same.
    -b | --build-conf)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_build_conf="$2"
      shift
      evaluate_strictness "$_key" "$_arg_build_conf"
      ;;
    # See the comment of option '--out=' to see what's going on here - principle is the same.
    --build-conf=*)
      _arg_build_conf="${_key##--build-conf=}"
      evaluate_strictness "$_key" "$_arg_build_conf"
      ;;
    # See the comment of option '-o' to see what's going on here - principle is the same.
    -b*)
      _arg_build_conf="${_key##-b}"
      evaluate_strictness "$_key" "$_arg_build_conf"
      ;;
    # See the comment of option '--update' to see what's going on here - principle is the same.
    -h | --help)
      exit 0
      ;;
    # See the comment of option '-u' to see what's going on here - principle is the same.
    -h*)
      exit 0
      ;;
    *)
      _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
      ;;
    esac
    shift
  done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

echo "Value of --option: $_arg_out $_arg_rollback $_arg_checkout"

# ] <-- needed because of Argbash
